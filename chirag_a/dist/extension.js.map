{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://codeflow-ch/./src/getNonce.ts","webpack://codeflow-ch/./src/extension.ts","webpack://codeflow-ch/external node-commonjs \"child_process\"","webpack://codeflow-ch/external commonjs \"vscode\"","webpack://codeflow-ch/./src/initial.ts","webpack://codeflow-ch/external node-commonjs \"path\"","webpack://codeflow-ch/webpack/bootstrap","webpack://codeflow-ch/webpack/startup"],"sourcesContent":["\nexport function getNonce() {\n\tlet text = '';\n\tconst possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\tfor (let i = 0; i < 32; i++) {\n\t\ttext += possible.charAt(Math.floor(Math.random() * possible.length));\n\t}\n\treturn text;\n}","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from \"vscode\";\nimport { InitialPanel } from \"./initial\";\nimport * as path from \"path\";\nimport { exec } from \"child_process\";\n\nexport let executionLogData = \"\";\n\nexport function executeFile(filePath: string) {\n  const ext = path.extname(filePath);\n\n  let command: string;\n  if (ext === \".js\") {\n    command = `node \"${filePath}\"`;\n  } else if (ext === \".py\") {\n    command = `python \"${filePath}\"`;\n  } else if (ext === \".sh\") {\n    command = `sh \"${filePath}\"`;\n  } else {\n    vscode.window.showErrorMessage(`Unsupported file type: ${ext}`);\n    return;\n  }\n\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      vscode.window.showErrorMessage(`Execution Error: ${error.message}`);\n      return;\n    }\n    vscode.window.showInformationMessage(`Output:\\n${stdout}`);\n    if (stderr) {\n      console.error(`Execution Stderr: ${stderr}`);\n    }\n  });\n}\nexport function activate(context: vscode.ExtensionContext) {\n  console.log('Congratulations, your extension \"codeflow\" is now active!');\n  \n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"codeflow.graphGenerator\", () => {\n      InitialPanel.createOrShow(context.extensionUri);\n    })\n  );\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"codeflow.refresh\", () => {\n      InitialPanel.kill();\n      InitialPanel.createOrShow(context.extensionUri);\n    })\n  );\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"codeflow.executeFile\", async () => {\n      if (InitialPanel.currentPanel) {\n        InitialPanel.currentPanel._executeFile();\n      } else {\n        vscode.window.showErrorMessage(\"Please open CodeFlow first\");\n      }\n    })\n  );\n  // let disposable = vscode.commands.registerCommand('codeflow.executeFile', async () => {\n  //     // Get all files in the workspace\n  //     const files = await vscode.workspace.findFiles('**/*'); // Modify pattern if needed\n\n  //     if (files.length === 0) {\n  //         vscode.window.showInformationMessage(\"No files found in the workspace.\");\n  //         return;\n  //     }\n\n  //     // Show file picker\n  //     const selectedFile = await vscode.window.showQuickPick(\n  //         files.map(file => file.fsPath),\n  //         { placeHolder: \"Select a file to execute\" }\n  //     );\n\n  //     if (!selectedFile) {\n  //         return;\n  //     }\n\n  // \t// Execute the selected file and collect logs\n  // \texec(`node \"${selectedFile}\"`, (error, stdout, stderr) => {\n  // \t\tif (error) {\n  // \t\tvscode.window.showErrorMessage(`Execution Error: ${error.message}`);\n  // \t\treturn;\n  // \t\t}\n  // \t\tvscode.window.showInformationMessage(`Output:\\n${stdout}`);\n  // \t\tif (stderr) {\n  // \t\tconsole.error(`Execution Stderr: ${stderr}`);\n  // \t\t}\n  // \t\tlet executionLogData = {\n  // \t\t\tfile: selectedFile,\n  // \t\t\toutput: stdout,\n  // \t\t\terror: stderr\n  // \t\t};\n  // \t\t// Collect logs\n  // \t\tconst logFilePath = path.join(context.logUri.fsPath, 'execution.log');\n  // \t\tconst workspaceLogFilePath = path.join(vscode.workspace.workspaceFolders![0].uri.fsPath, 'logs', 'execution.log');\n  // \t\tlet logData = `File: ${selectedFile}\\nOutput:\\n${stdout}\\nError:\\n${stderr}\\n\\n`;\n  // \t\t// Save logs to extension log directory\n  // \t\tvscode.workspace.fs.writeFile(vscode.Uri.file(logFilePath), Buffer.from(logData, 'utf8'))\n  // \t\t.then(\n  // \t\t\t() => {\n  // \t\t\t\tvscode.window.showInformationMessage(`Logs saved to ${logFilePath}`);\n  // \t\t\t},\n  // \t\t\t(err: any) => {\n  // \t\t\t\tvscode.window.showErrorMessage(`Failed to save logs: ${err.message}`);\n  // \t\t\t}\n  // \t\t);\n  // \t\tif (InitialPanel.currentPanel) {\n  // \t\t\tInitialPanel.currentPanel.webview.postMessage({\n  // \t\t\t\ttype: 'onInfo',\n  // \t\t\t\tvalue: `Logs saved to ${logFilePath}`\n  // \t\t\t});\n  // \t\t}\n  // \t\t// Save logs to workspace logs directory\n  // \t\tif (vscode.workspace.workspaceFolders) {\n  // \t\t\tvscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(workspaceLogFilePath))).then(() => {\n  // \t\t\t\tvscode.workspace.fs.writeFile(vscode.Uri.file(workspaceLogFilePath), Buffer.from(logData, 'utf8'))\n  // \t\t\t\t.then(\n  // \t\t\t\t\t() => {\n  // \t\t\t\t\t\tvscode.window.showInformationMessage(`Logs also saved to ${workspaceLogFilePath}`);\n  // \t\t\t\t\t},\n  // \t\t\t\t\t(err: any) => {\n  // \t\t\t\t\t\tvscode.window.showErrorMessage(`Failed to save logs to workspace: ${err.message}`);\n  // \t\t\t\t\t}\n  // \t\t\t\t);\n  // \t\t\t});\n  // \t\t} else {\n  // \t\t\tvscode.window.showErrorMessage('No workspace folder is open. Logs cannot be saved to workspace.');\n  // \t\t}\n  // \t});\n  // });\n\n  // context.subscriptions.push(disposable);\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"codeflow.askQuestion\", async () => {\n      const answer = await vscode.window.showInformationMessage(\n        \"How are you?\",\n        \"Good\",\n        \"Bad\"\n      );\n      if (answer === \"Good\") {\n        vscode.window.showInformationMessage(\"I am glad to hear that!\");\n      } else if (answer === \"Bad\") {\n        vscode.window.showInformationMessage(\"I am sorry to hear that!\");\n      }\n    })\n  );\n}\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n","module.exports = require(\"child_process\");","module.exports = require(\"vscode\");","import * as vscode from \"vscode\";\nimport { exec } from \"child_process\";\nimport { getNonce } from \"./getNonce\";\nimport * as path from \"path\";\nimport * as fs from \"fs\";\n\n\nexport class InitialPanel {\n  static kill() {\n    if (InitialPanel.currentPanel) {\n      InitialPanel.currentPanel.dispose();\n      InitialPanel.currentPanel = undefined;\n    }\n  }\n  public static currentPanel: InitialPanel | undefined;\n  public static readonly viewType = \"initial\";\n\n  private readonly _panel: vscode.WebviewPanel;\n  private readonly _extensionUri: vscode.Uri;\n  private _disposables: vscode.Disposable[] = [];\n\n  public static createOrShow(extensionUri: vscode.Uri) {\n    const column = vscode.window.activeTextEditor\n      ? vscode.window.activeTextEditor.viewColumn\n      : undefined;\n\n    if (InitialPanel.currentPanel) {\n      InitialPanel.currentPanel._panel.reveal(column);\n      return;\n    }\n\n    const panel = vscode.window.createWebviewPanel(\n      InitialPanel.viewType,\n      \"CodeFlow\",\n      column || vscode.ViewColumn.One,\n      {\n        enableScripts: true,\n        localResourceRoots: [\n          vscode.Uri.joinPath(extensionUri, \"media\"),\n          vscode.Uri.joinPath(extensionUri, \"out/compiled\"),\n        ],\n      }\n    );\n\n    InitialPanel.currentPanel = new InitialPanel(panel, extensionUri);\n  }\n\n  private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {\n    this._panel = panel;\n    this._extensionUri = extensionUri;\n    this._update();\n\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    // Handle messages from the webview\n    this._panel.webview.onDidReceiveMessage(\n      async (message) => {\n        switch (message.type) {\n          case \"executeFile\":\n            await this._executeFile();\n            break;\n          case \"onInfo\":\n            if (!message.value) {\n              return;\n            }\n            vscode.window.showInformationMessage(message.value);\n            if (!message.value) {\n              return;\n            }\n            vscode.window.showErrorMessage(message.value);\n            if (!message.value) {\n              return;\n            }\n            vscode.window.showErrorMessage(message.value);\n            break;\n        }\n      },\n      null,\n      this._disposables\n    );\n  }\n\n  public async _executeFile() {\n    // Get all files in the workspace\n    const files = await vscode.workspace.findFiles(\"**/*\");\n\n    if (files.length === 0) {\n      vscode.window.showInformationMessage(\"No files found in the workspace.\");\n      return;\n    }\n\n    const selectedFile = await vscode.window.showQuickPick(\n      files.map((file) => file.fsPath),\n      { placeHolder: \"Select a file to execute\" }\n    );\n\n    if (!selectedFile) {\n      return;\n    }\n\n    // Create logs directory if it doesn't exist\n    const logsDir = path.join(this._extensionUri.fsPath, \"logs\");\n    await vscode.workspace.fs.createDirectory(vscode.Uri.file(logsDir));\n\n    // Execute the selected file\n    exec(`node \"${selectedFile}\"`, async (error, stdout, stderr) => {\n      // Create log data\n      const logData = `File: ${selectedFile}\\nOutput:\\n${stdout}\\nError:\\n${stderr}\\n\\nExecuted at: ${new Date().toISOString()}\\n\\n`;\n\n      // Save logs to file\n      const logFilePath = path.join(logsDir, \"execution.log\");\n      try {\n        await vscode.workspace.fs.writeFile(\n          vscode.Uri.file(logFilePath),\n          Buffer.from(logData, \"utf8\")\n        );\n\n        // Update webview with execution results\n        this._panel.webview.postMessage({\n          type: \"log\",\n          content: logData,\n        });\n\n        vscode.window.showInformationMessage(`Logs saved to ${logFilePath}`);\n      } catch (err: any) {\n        vscode.window.showErrorMessage(`Failed to save logs: ${err.message}`);\n      }\n\n      if (error) {\n        vscode.window.showErrorMessage(`Execution Error: ${error.message}`);\n      }\n    });\n  }\n\n  public dispose() {\n    InitialPanel.currentPanel = undefined;\n    this._panel.dispose();\n\n    while (this._disposables.length) {\n      const x = this._disposables.pop();\n      if (x) {\n        x.dispose();\n      }\n    }\n  }\n\n  private _update() {\n    const webview = this._panel.webview;\n    this._panel.webview.html = this._getHtmlForWebview(webview);\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"media\", \"main.js\")\n    );\n\n    const stylesResetUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"css\", \"styles.css\")\n    );\n    const stylesMainUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, \"media\", \"vscode.css\")\n    );\n\n    const nonce = getNonce();\n\n    return `<!DOCTYPE html>\n<html>\n<head>\n  <title>Dynamic Graph</title>\n  <script type=\"text/javascript\" src=\"https://unpkg.com/vis-network/standalone/umd/vis-network.min.js\"></script>\n  <style>\n    #mynetwork {\n      width: 100%;\n      height: 600px;\n      border: 1px solid lightgray;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"mynetwork\"></div>\n\n  <script>\n    const SERVER_URL = \"ws://localhost:3000\";\n    const socket = new WebSocket(SERVER_URL);\n    const allMessages = [];\n\n    // vis.js DataSets\n    const nodes = new vis.DataSet([]);\n    const edges = new vis.DataSet([]);\n    let uniqueIdCounter = 1;\n    \n    function generateUniqueId() {\n      return uniqueIdCounter++;\n    }\n\n    let nodeIds = [];\n    const container = document.getElementById('mynetwork');\n    const data = { nodes, edges };\n    const options = {\n      nodes: {\n        shape: 'dot',\n        size: 20\n      },\n      edges: {\n        color: 'gray',\n        arrows: {\n          to: { enabled: true, scaleFactor: 0.5 }\n        }\n      },\n      physics: {\n        enabled: true,\n        solver: 'forceAtlas2Based'\n      }\n    };\n\n    const network = new vis.Network(container, data, options);\n\n    function rebuildGraph() {\n      nodes.clear();\n      edges.clear();\n      nodeIds = [];\n\n      // Sort allMessages by raw_json.sequence\n      allMessages.sort((a, b) => {\n        const seqA = a.raw_json?.sequence ?? 0;\n        const seqB = b.raw_json?.sequence ?? 0;\n        return seqA - seqB;\n      });\n\n      // First pass: create exactly one node per message\n      for (let i = 0; i < allMessages.length; i++) {\n        const msg = allMessages[i];\n        const { raw_json } = msg;\n        const { method, status, error, stackTrace } = raw_json;\n\n        // Decide color and shape based on error type\n        let color = \"gray\";\n        let shape = \"dot\";\n        let size = 20;\n        \n        if (status === \"error\") {\n          color = \"red\";\n          shape = \"diamond\"; // Error nodes are diamonds\n          size = 25;\n        } else if (status === \"success\") {\n          color = \"green\";\n        }\n\n        // Create a brand-new node for this message\n        const newNodeId = generateUniqueId();\n        nodeIds.push(newNodeId);\n\n        // Create detailed tooltip with error info\n        let tooltip = \"Function: \" + method + \"\\\\nStatus: \" + status;\n        if (error) {\n          tooltip += \"\\\\nError: \" + error;\n        }\n        if (stackTrace) {\n          tooltip += \"\\\\n\\\\nStack Trace:\\\\n\" + stackTrace;\n        }\n        if (raw_json.parameters) {\n          tooltip += \"\\\\n\\\\nParameters: \" + JSON.stringify(raw_json.parameters, null, 2);\n        }\n\n        // Add to nodes DataSet\n        nodes.add({\n          id: newNodeId,\n          label: method || \"unknown\",\n          color: color,\n          shape: shape,\n          size: size,\n          title: tooltip,\n          font: {\n            size: status === \"error\" ? 14 : 12,\n            bold: status === \"error\"\n          }\n        });\n      }\n\n      // Second pass: create edges based on next_calls\n      for (let i = 0; i < allMessages.length; i++) {\n        const fromMsg = allMessages[i];\n        const fromSeq = fromMsg.raw_json?.sequence ?? 0;\n        const fromNodeId = nodeIds[i];\n        const nextCalls = fromMsg.raw_json?.next_calls || [];\n\n        // For each next_call in fromMsg\n        nextCalls.forEach(callName => {\n          // Find a future message whose raw_json.method == callName\n          // and has a sequence > fromSeq\n          let bestJ = null;\n          let bestSeq = Infinity;\n\n          for (let j = 0; j < allMessages.length; j++) {\n            if (j === i) continue; // don't link to itself\n            const toMsg = allMessages[j];\n            const toSeq = toMsg.raw_json?.sequence ?? 0;\n            if (\n              toSeq > fromSeq && \n              toMsg.raw_json?.method === callName &&\n              toSeq < bestSeq\n            ) {\n              bestJ = j;\n              bestSeq = toSeq;\n            }\n          }\n\n          // If we found a suitable future message, link them\n          if (bestJ !== null) {\n            edges.add({\n              from: fromNodeId,\n              to: nodeIds[bestJ]\n            });\n          }\n        });\n      }\n    }\n\n    // Socket events\n    socket.onopen = () => {\n      console.log(\"Connected to WebSocket Server at \" + SERVER_URL);\n    };\n\n    socket.onmessage = (event) => {\n      try {\n        const jsonData = JSON.parse(event.data);\n        console.log(\"Received WebSocket data:\", jsonData);\n        allMessages.push(jsonData);\n        rebuildGraph();\n      } catch (error) {\n        console.error(\"Error parsing WebSocket data:\", error);\n      }\n    };\n\n    socket.onclose = () => {\n      console.log(\"WebSocket disconnected from \" + SERVER_URL);\n    };\n  </script>\n</body>\n</html>\n`;\n  }\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["text","i","charAt","Math","floor","possible","random","filePath","ext","path","extname","command","vscode","window","showErrorMessage","exec","error","stdout","stderr","message","showInformationMessage","console","context","log","subscriptions","push","commands","registerCommand","InitialPanel","createOrShow","extensionUri","kill","currentPanel","_executeFile","answer","executionLogData","module","exports","require","dispose","undefined","column","activeTextEditor","viewColumn","_panel","reveal","panel","createWebviewPanel","viewType","ViewColumn","One","enableScripts","localResourceRoots","Uri","joinPath","_disposables","this","_extensionUri","_update","onDidDispose","webview","onDidReceiveMessage","type","value","files","workspace","findFiles","length","selectedFile","showQuickPick","map","file","fsPath","placeHolder","logsDir","join","fs","createDirectory","logData","Date","toISOString","logFilePath","writeFile","Buffer","from","postMessage","content","err","x","pop","html","_getHtmlForWebview","asWebviewUri","getNonce","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}